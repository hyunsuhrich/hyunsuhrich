<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Teachable Machine Character</title>

    <!-- ✅ Teachable Machine + TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>

    <style>
      body {
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        background: #f2f5f8;
        font-family: "Noto Sans KR", sans-serif;
      }
      #canvas {
        border: 3px solid #444;
        border-radius: 10px;
        background: #fff;
      }
      h1 {
        margin-bottom: 20px;
      }
    </style>
  </head>
  <body>
    <h1>Teachable Machine Character</h1>
    <canvas id="canvas" width="400" height="400"></canvas>

    <script>
      const URL = "https://teachablemachine.withgoogle.com/models/Sny7WS_GP/";
      let model, webcam, labelContainer, maxPredictions;
      let characterX = 200;
      let characterY = 300;
      let velocityY = 0;
      let isJumping = false;

      const ACTIONS = {
        "왼쪽": "left",
        "오른쪽": "right",
        "점프": "jump",
        "가만히": "idle",
      };

      async function init() {
        const modelURL = URL + "model.json";
        const metadataURL = URL + "metadata.json";

        // ✅ 모델과 메타데이터 로드
        model = await tmImage.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();

        // ✅ 웹캠 세팅
        const flip = true;
        webcam = new tmImage.Webcam(200, 200, flip);
        await webcam.setup();
        await webcam.play();
        window.requestAnimationFrame(loop);

        // ✅ 웹캠 화면 추가
        document.body.appendChild(webcam.canvas);
      }

      async function loop() {
        webcam.update();
        await predict();
        drawCharacter();
        window.requestAnimationFrame(loop);
      }

      async function predict() {
        const prediction = await model.predict(webcam.canvas);
        let highest = prediction[0];
        for (let i = 1; i < prediction.length; i++) {
          if (prediction[i].probability > highest.probability) {
            highest = prediction[i];
          }
        }

        const action = ACTIONS[highest.className];
        handleAction(action);
      }

      function handleAction(action) {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        if (action === "left") {
          characterX -= 5;
        } else if (action === "right") {
          characterX += 5;
        } else if (action === "jump" && !isJumping) {
          isJumping = true;
          velocityY = -10;
        }

        if (isJumping) {
          characterY += velocityY;
          velocityY += 0.5;
          if (characterY >= 300) {
            characterY = 300;
            isJumping = false;
          }
        }
      }

      function drawCharacter() {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ✅ 바닥
        ctx.fillStyle = "#ccc";
        ctx.fillRect(0, 350, 400, 50);

        // ✅ 캐릭터
        ctx.fillStyle = "#007bff";
        ctx.beginPath();
        ctx.arc(characterX, characterY, 25, 0, Math.PI * 2);
        ctx.fill();
      }

      init();
    </script>
  </body>
</html>
